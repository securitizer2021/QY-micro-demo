<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>IDT Anchor Horizon Recommender ‚Äî IS/OS + Charts</title>
<style>
  :root{
    --bg:#0e1116; --card:#151922; --text:#e8eaed; --muted:#9aa0a6; --border:#2a2f3a;
    --chart-h: 280px;
  }
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1280px;margin:0 auto;padding:24px}
  .sub{color:var(--muted);margin-bottom:20px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
  .controls{display:grid;grid-template-columns:1.3fr 1fr 1fr;gap:16px}
  select,input[type="range"]{width:100%}
  .slider-labels{display:flex;justify-content:space-between;color:var(--muted);font-size:12px;margin-top:6px}
  .row{display:flex;gap:16px;flex-wrap:wrap;margin-top:12px}
  .pill{padding:6px 10px;border-radius:999px;background:#1b2130;border:1px solid var(--border);color:#dfe3ea;cursor:pointer}
  .pill.good{background:rgba(15,157,88,.15);border-color:#224f38;color:#b9ffd3}
  .pill.warn{background:rgba(122,162,255,.15);border-color:#283e7a;color:#cfe0ff}
  .pill.alt {background:rgba(244,180,0,.12);border-color:#564600;color:#ffe9ad}
  .recs{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}

  .panes{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:12px}
  .pane{display:flex;flex-direction:column;gap:16px}

  /* Chart container */
  .chartbox{position:relative;height:var(--chart-h);width:100%}
  .chartbox canvas{
    width:100% !important;height:100% !important;display:block;
    background:#0f1420;border:1px solid var(--border);border-radius:12px;padding:8px;
  }

  /* tables */
  table{width:100%;border-collapse:collapse;background:var(--card);border:1px solid var(--border);border-radius:12px;overflow:visible;table-layout:auto}
  thead th{position:sticky;top:0;background:#1b2130;padding:10px;border-bottom:1px solid var(--border);text-align:left;white-space:nowrap}
  tbody td{padding:10px;border-top:1px solid var(--border);vertical-align:top;white-space:nowrap}
  .num{font-variant-numeric:tabular-nums;text-align:right}
  .foot{margin-top:10px;color:var(--muted);font-size:12px}
  .section-title{font-weight:700;margin-bottom:6px}
  .kwrap{display:flex;gap:8px;align-items:center}
  .small-select{width:auto;min-width:84px;padding-right:18px}

  /* panel controls */
  .panel-controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  .muted{color:var(--muted)}

  /* ======= Tooltip (CSS-only) ======= */
  .tt{position:relative; cursor:help; display:inline-block}
  .tt::after{
    content: attr(data-tip);
    position:absolute; left:0; bottom:calc(100% + 8px);
    background:#0f1420; color:#e8eaed; border:1px solid #2a2f3a;
    padding:8px 10px; border-radius:8px; min-width:220px; max-width:340px;
    font-size:12px; line-height:1.35; white-space:normal;
    box-shadow:0 6px 18px rgba(0,0,0,.35);
    opacity:0; transform:translateY(6px); pointer-events:none; transition:opacity .15s ease, transform .15s ease;
    z-index:10;
  }
  .tt::before{
    content:""; position:absolute; left:10px; bottom:calc(100% + 4px);
    border:6px solid transparent; border-top-color:#2a2f3a; opacity:0; transform:translateY(6px); transition:opacity .15s ease, transform .15s ease;
    z-index:11;
  }
  .tt:hover::after, .tt:hover::before{opacity:1; transform:translateY(0)}

  #riskTable, #simTable { font-size:12px; }

  /* ‚úÖ FIX: horizons area scroll box so it never overlaps chart */
  .chk-scroll{
    max-height: 98px;
    overflow:auto;
    border:1px solid var(--border);
    border-radius:10px;
    padding:8px;
    background:#101624;
  }
  .chk-wrap{display:flex;gap:8px;flex-wrap:wrap}
  .chk-wrap label{display:inline-flex;gap:6px;align-items:center;background:#121a2a;border:1px solid var(--border);padding:4px 8px;border-radius:999px}

  /* extra spacing between checkboxes and chart */
  .chart-spacer{height:10px}

  /* Auto-width chip for Total PnL cells */
  .pnlChip{
    display:inline-flex;
    align-items:center;
    justify-content:flex-end;
    width:fit-content;
    max-width:100%;
    padding:2px 10px;
    border-radius:999px;
    border:1px solid var(--border);
    background:#121a2a;
    white-space:nowrap;
    font-variant-numeric: tabular-nums;
  }
</style>
</head>
<body>
<div class="wrap">
  <div style="display:flex;align-items:center;justify-content:left;gap:12px;margin-bottom:12px">
      <a href="https://quantumyield.ai" target="_blank" rel="noopener noreferrer">
        <img src="https://quantumyield.ai/logo.jpg" alt="Quantum Yield Logo" style="height:36px;width:auto;border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,.25)">
      </a>
      <h2 style="margin:0">Trading Optimizer (IDT)</h2>
  </div>

  <div class="sub">
    Daily intra-day trading simulation with user-defined risk and performance preferences, ranking horizons to identify top-performing strategies.
  </div>

  <div class="controls">
    <div class="card">
      <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px">
        <div>
          <label for="asof">As-of Date</label>
          <select id="asof"></select>
          <div class="foot">Format: <b>yyyymmdd</b></div>
        </div>
        <div>
          <label for="instrument">Instrument</label>
          <select id="instrument">
            <option value="ZN">ZN (10Y Treasury Futures)</option>
            <option value="ES" selected>ES (S&P 500 Futures)</option>
            <option value="MBT">MBT(Micro Bitcoin Futures)</option>
          </select>
        </div>
        <div>
          <label for="tagSel">IS/OS</label>
          <select id="tagSel">
            <option value="OS" selected>OS</option>
            <option value="IS">IS</option>
          </select>
          <div class="foot">Computed by asof vs model window</div>
        </div>
      </div>
      <div class="foot" id="status" style="margin-top:8px"></div>
    </div>

    <div class="card">
      <label for="risk">Risk Scale</label>
      <input id="risk" type="range" min="0" max="100" step="1" value="50" />
      <div class="slider-labels"><span>Conservative</span><span>Balanced</span><span>Aggressive</span></div>
      <div class="foot">Risk Score = wS¬∑Sharpe ‚àí wT¬∑Turnover ‚àí wD¬∑MaxDD (scaled 0‚Äì10).</div>
    </div>

    <div class="card">
      <label for="perf">Performance Scale</label>
      <input id="perf" type="range" min="0" max="100" step="1" value="60" />
      <div class="slider-labels"><span>Conservative</span><span>Balanced</span><span>Aggressive</span></div>
      <div class="foot">
        Perf Score uses ONLY these 5 metrics: Total, Avg, Median, Win%, Trades (robust-scaled, 0‚Äì10).
      </div>
    </div>
  </div>

  <div class="row">
    <div class="card" style="flex:1">
      <div class="section-title">Top-K Recommendations</div>
      <div class="kwrap">
        <label for="topk">Show top</label>
        <select id="topk" class="small-select">
          <option>1</option><option>2</option><option selected>3</option>
          <option>4</option><option>5</option><option>6</option><option>7</option>
        </select>
        <span>anchors</span>
      </div>
      <div style="margin-top:10px"><b>Risk-based</b></div>
      <div id="recsRisk" class="recs"></div>
      <div style="margin-top:10px"><b>Performance-based</b></div>
      <div id="recsPerf" class="recs"></div>
    </div>
  </div>

  <div class="panes">
    <!-- LEFT PANE (RISK) -->
    <div class="pane">
      <div class="card" id="riskCard">
        <div class="section-title">Risk by Horizon</div>
        <div class="panel-controls">
          <label for="riskMetricSel">Metric</label>
          <select id="riskMetricSel" class="small-select">
            <option value="Sharpe">Sharpe</option>
            <option value="MaxDD">MaxDD</option>
            <option value="Turnover">Turnover</option>
            <option value="Utility">Utility</option>
            <option value="riskScoreN" selected>Risk Score (0‚Äì10)</option>
          </select>
          <span class="muted">Anchors</span>
          <button id="riskAnchorsAll" class="pill">All</button>
          <button id="riskAnchorsNone" class="pill">None</button>
        </div>

        <div class="chk-scroll">
          <div id="anchorChecksRisk" class="chk-wrap"></div>
        </div>

        <div class="chart-spacer"></div>
        <div class="chartbox"><canvas id="riskChart"></canvas></div>
      </div>

      <div class="card">
        <div class="section-title">Risk Metrics</div>
        <table id="riskTable">
          <thead>
            <tr>
              <th>Horizon (ms)</th>
              <th>œÑ</th>
              <th>q</th>
              <th>Sharpe</th>
              <th>Turnover</th>
              <th>MaxDD</th>
              <th>Utility</th>
              <th>Risk Score (0‚Äì10)</th>
            </tr>
          </thead><tbody></tbody>
        </table>
      </div>
    </div>

    <!-- RIGHT PANE (PERFORMANCE) -->
    <div class="pane">
      <div class="card" id="perfCard">
        <div class="section-title">Performance by Horizon</div>
        <div class="panel-controls">
          <label for="metricSel">Metric</label>
          <select id="metricSel" class="small-select">
            <option value="total_pnl_bps">Total PnL (bps)</option>
            <option value="avg_pnl_bps">Avg PnL (bps)</option>
            <option value="med_pnl_bps">Median PnL (bps)</option>
            <option value="win_pct">Win %</option>
            <option value="trades">Trades</option>
            <option value="perfScoreN" selected>Perf Score (0‚Äì10)</option>
          </select>
          <span class="muted">Anchors</span>
          <button id="anchorsAll" class="pill">All</button>
          <button id="anchorsNone" class="pill">None</button>
        </div>

        <div class="chk-scroll">
          <div id="anchorChecks" class="chk-wrap"></div>
        </div>

        <div class="chart-spacer"></div>
        <div class="chartbox"><canvas id="pnlChart"></canvas></div>
      </div>

      <div class="card">
        <div class="section-title">Simulation Results</div>
        <table id="simTable">
          <thead>
            <tr>
              <th>Horizon</th>
              <th>Trades</th>
              <th>Total PnL (bps)</th>
              <th>Avg PnL</th>
              <th>Median PnL</th>
              <th>Profit</th>
              <th>Loss</th>
              <th>Flat</th>
              <th>Win %</th>
              <th>Perf Score (0‚Äì10)</th>
            </tr>
          </thead><tbody></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
/* ========= JSON Data Source ========= */
const JSON_URL = "./daily_data.json";

/* -------- Colors per metric -------- */
const METRIC_COLORS = {
  Sharpe:'#4ade80', MaxDD:'#ef4444', Turnover:'#f59e0b', Utility:'#22c55e', riskScoreN:'#06b6d4',
  total_pnl_bps:'#60a5fa', avg_pnl_bps:'#a78bfa', med_pnl_bps:'#ec4899', win_pct:'#10b981', trades:'#f97316', perfScoreN:'#eab308'
};

let cache = {};                 // key = `${asof}_${sym}_${tag}`
let pnlChart=null, riskChart=null;
let lastRows=[];
let renderSeq=0, currentKey="";
let RAW=null;

/* equalize the two top chart *cards* */
function syncChartCardHeights(){
  const left = document.getElementById('riskCard');
  const right = document.getElementById('perfCard');
  if(!left || !right) return;
  left.style.height = right.style.height = 'auto';
  const h = Math.max(left.getBoundingClientRect().height, right.getBoundingClientRect().height);
  left.style.height = right.style.height = h + 'px';
}

/* ------------------------ Fetch JSON ------------------------ */
async function loadJSON(){
  const r = await fetch(JSON_URL, {cache:"no-store"});
  if(!r.ok) throw new Error(`Failed to load ${JSON_URL} (${r.status})`);
  const j = await r.json();
  if(!Array.isArray(j)) throw new Error("idt|hft_daily_data_1.json must be an array of records");
  return j;
}

/* ------------------------ Helpers ------------------------ */
function num(x, dflt=0){
  const v = +x;
  return Number.isFinite(v) ? v : dflt;
}
function yyyymmdd(asof){
  const s = String(asof||"");
  return (s.length === 8 && s.startsWith("20")) ? s : null;
}

/* ------------------------ Populate As-of dropdown ------------------------ */
function populateAsofs(){
  const sel = document.getElementById('asof');
  const asofs = Array.from(new Set(RAW.map(r => yyyymmdd(r.asof)).filter(Boolean)))
    .sort(); // ascending
  sel.innerHTML = asofs.map(d=>`<option value="${d}">${d}</option>`).join('');

  // default to latest
  if(asofs.length) sel.value = asofs[asofs.length-1];
}

/* ------------------------ Build rows for (asof,symbol,tag) ------------------------ */
function buildRowsFor(asof, sym, tag){
  const SYM = String(sym||"").toUpperCase();
  const TAG = String(tag||"").toUpperCase();
  const ASOF = String(asof||"");

  // Filter to the exact slice we want
  const slice = RAW.filter(r =>
    String(r.symbol||"").toUpperCase() === SYM &&
    String(r.asof||"") === ASOF &&
    String(r.tag||"").toUpperCase() === TAG
  );

  if(!slice.length) return {rows:[], meta:null};

  // Map into per-horizon rows
  const rows = slice.map(r => {
      const h = num(r.horizon_ms ?? r.h_ms ?? r.horizon, NaN);

      // Prefer explicit fields in JSON; fallback to compatible names
      const Sharpe = Number.isFinite(+ (r.Sharpe ?? r.sharpe)) ? +(r.Sharpe ?? r.sharpe) : NaN;
      const Turnover = num(r.Turnover ?? r.num_trades ?? r.trades ?? r.count, 0);
      const MaxDD = num(r.MaxDD ?? r.mxDD ?? r.maxdd, 0);

      const Utility = Number.isFinite(num(r.Utility, NaN))
        ? num(r.Utility)
        : (Sharpe - 0.001*Turnover - 0.5*MaxDD);

      const avg = num(r.avg_pnl_bps ?? r.mean_trades_bps ?? r.mean_all_bps, 0);
      const total = Number.isFinite(num(r.total_pnl_bps, NaN)) ? num(r.total_pnl_bps) : (avg * Turnover);
      const med = num(r.med_pnl_bps ?? r.median_bps ?? r.median_bps, 0);

      const profit = num(r.profit_trades, 0);
      const loss   = num(r.losing_trades, 0);
      const flat   = num(r.flat, 0);
      const winpct = Number.isFinite(num(r.win_pct, NaN))
        ? num(r.win_pct)
        : (Number.isFinite(num(r.win_rate, NaN)) ? num(r.win_rate) : 0);

      const tau = Number.isFinite(num(r.tau, NaN)) ? num(r.tau) : NaN;
      const q   = Number.isFinite(num(r.q, NaN)) ? num(r.q) : NaN;

      return {
        h_ms:h, tau, q,
        trades:Turnover,
        total_pnl_bps: total,
        avg_pnl_bps: avg,
        med_pnl_bps: med,
        profit_trades: profit,
        losing_trades: loss,
        flat: flat,
        win_pct: winpct,
        Sharpe, Turnover, MaxDD, Utility,

        // provenance (optional)
        model_start: r.model_start,
        model_end: r.model_end,
        src_file: r.src_file
      };
    })
    .filter(r => Number.isFinite(r.h_ms))
    .sort((a,b)=>a.h_ms-b.h_ms);

  // Detect duplicates per horizon
  const dup = rows.length - new Set(rows.map(r=>r.h_ms)).size;

  const meta = {
    asof: ASOF,
    symbol: SYM,
    tag: TAG,
    rows: rows.length,
    dup_horizons: dup
  };

  return {rows, meta};
}

/* ============================================================================
   ‚úÖ REVISED TOP-K SCORING (INTUITION-FIXED)
   Uses ONLY the 3 risk metrics and 5 performance metrics.
   Adds dominance filtering (Perf) so a worse-across-all horizon can't win.
   Fixes DD unit scale if it looks like bps.
   Fixes Sharpe missing behavior (no more -10 forcing tiny horizons to ‚Äúwin‚Äù).
   Uses rank-based normalization to avoid ties at 10.
   ============================================================================ */

/* ---------- robust scaling helpers ---------- */
function _finiteVals(rows, key){
  return rows.map(r => +r[key]).filter(v => Number.isFinite(v));
}
function _quantile(sortedVals, q){
  if(!sortedVals.length) return NaN;
  const pos = (sortedVals.length - 1) * q;
  const lo = Math.floor(pos);
  const hi = Math.ceil(pos);
  if(lo === hi) return sortedVals[lo];
  const t = pos - lo;
  return sortedVals[lo] * (1 - t) + sortedVals[hi] * t;
}
function _robust01(v, p10, p90){
  if(!Number.isFinite(v) || !Number.isFinite(p10) || !Number.isFinite(p90) || p90 <= p10) return 0.5;
  const x = (v - p10) / (p90 - p10);
  return Math.max(0, Math.min(1, x));
}
function _robustStats(rows, key){
  const vals = _finiteVals(rows, key).sort((a,b)=>a-b);
  return {
    p10: _quantile(vals, 0.10),
    p50: _quantile(vals, 0.50),
    p90: _quantile(vals, 0.90),
    min: vals.length ? vals[0] : NaN,
    max: vals.length ? vals[vals.length-1] : NaN
  };
}

/* ---------- unit sanity ---------- */
function _ensureDDScale(rows){
  const ddVals = _finiteVals(rows, 'MaxDD');
  if(!ddVals.length) return;

  const p90 = _quantile(ddVals.slice().sort((a,b)=>a-b), 0.90);

  // If MaxDD looks like bps (e.g. 982, 3139), convert bps->pct.
  if(p90 > 50){
    rows.forEach(r=>{
      if(Number.isFinite(+r.MaxDD)) r.MaxDD = (+r.MaxDD)/100; // bps -> pct
    });
    console.log("[DD SCALE] MaxDD looked like bps; converted MaxDD = MaxDD/100 (bps->pct)");
  }
}
function _ensureSharpePresent(rows){
  const sharpeVals = _finiteVals(rows, 'Sharpe');
  if(sharpeVals.length >= Math.max(3, Math.floor(rows.length * 0.5))) return;
  console.warn("[SHARPE] Sharpe missing for many rows. Risk score degrades. Check JSON mapping for Sharpe.");
}

/* ---------- slider weights ---------- */
function riskWeights(x){
  const t = x/100;
  // Intuition: conservative -> punish DD & trades more; aggressive -> reward Sharpe more.
  return { wS: 0.8 + 0.6*t, wD: 1.2 - 0.5*t, wT: 0.6 - 0.25*t };
}
function perfWeights(x){
  const t = x/100;
  // Intuition: total/avg/median/win become more important when aggressive; trades penalty softens.
  return { vTot: 0.7 + 0.9*t, vAvg: 0.5 + 0.8*t, vMed: 0.3 + 0.6*t, vWin: 0.4 + 0.7*t, vTrd: 0.35 - 0.15*t };
}

/* ---------- risk/perf scoring using only your metrics ---------- */
function scoreRisk(r, W, RS){
  const uSharpe = _robust01(+r.Sharpe, RS.Sharpe.p10, RS.Sharpe.p90);      // higher better
  const uDD     = 1 - _robust01(+r.MaxDD, RS.MaxDD.p10, RS.MaxDD.p90);     // lower better
  const uTrd    = 1 - _robust01(+r.trades, RS.trades.p10, RS.trades.p90);  // lower better

  const sharpeOk = Number.isFinite(+r.Sharpe);
  const wS = sharpeOk ? W.wS : (0.25 * W.wS); // don‚Äôt nuke everything when Sharpe missing

  // raw score: higher better
  return (wS*uSharpe) + (W.wD*uDD) + (W.wT*uTrd);
}

function scorePerf(r, P, PS){
  const uTot = _robust01(+r.total_pnl_bps, PS.total_pnl_bps.p10, PS.total_pnl_bps.p90);
  const uAvg = _robust01(+r.avg_pnl_bps,   PS.avg_pnl_bps.p10,   PS.avg_pnl_bps.p90);
  const uMed = _robust01(+r.med_pnl_bps,   PS.med_pnl_bps.p10,   PS.med_pnl_bps.p90);
  const uWin = _robust01(+r.win_pct,       PS.win_pct.p10,       PS.win_pct.p90);
  const uTrd = 1 - _robust01(+r.trades,    PS.trades.p10,        PS.trades.p90);

  // Intuition hard stop: negative total pnl should not be ‚Äútop‚Äù unless everything is negative.
  const totalNeg = Number.isFinite(+r.total_pnl_bps) && (+r.total_pnl_bps < 0);
  const negPenalty = totalNeg ? 0.25 : 0;

  return (P.vTot*uTot) + (P.vAvg*uAvg) + (P.vMed*uMed) + (P.vWin*uWin) + (P.vTrd*uTrd) - negPenalty;
}

/* ---------- rank normalization avoids 10/10 ties ---------- */
// function normalizeRank0_10(rows, rawKey, normKey){
//   const vals = rows.map(r => ({h:r.h_ms, v:+r[rawKey]})).filter(o => Number.isFinite(o.v));
//   vals.sort((a,b)=>a.v-b.v);

//   if(!vals.length){
//     rows.forEach(r => r[normKey] = 5);
//     return;
//   }
//   const allSame = vals[0].v === vals[vals.length-1].v;
//   if(allSame){
//     rows.forEach(r => r[normKey] = 5);
//     return;
//   }

//   const rankMap = new Map();
//   for(let i=0;i<vals.length;i++){
//     const pct = i/(vals.length-1); // 0..1
//     rankMap.set(vals[i].h, 10*pct);
//   }
//   rows.forEach(r=>{
//     r[normKey] = rankMap.has(r.h_ms) ? rankMap.get(r.h_ms) : 5;
//   });
// }
function normalizeRobust0_10(rows, rawKey, normKey){
  const vals = rows.map(r => +r[rawKey]).filter(v => Number.isFinite(v)).sort((a,b)=>a-b);

  if(!vals.length){
    rows.forEach(r => r[normKey] = 5);
    return;
  }

  const p10 = _quantile(vals, 0.10);
  const p90 = _quantile(vals, 0.90);

  // If nearly constant, avoid divide-by-zero and show neutral scores
  if(!Number.isFinite(p10) || !Number.isFinite(p90) || Math.abs(p90 - p10) < 1e-12){
    rows.forEach(r => r[normKey] = 5);
    return;
  }

  rows.forEach(r=>{
    const v = +r[rawKey];
    const u = _robust01(v, p10, p90);   // 0..1 (clipped)
    r[normKey] = 10 * u;               // 0..10
  });
}

/* ---------- dominance filter (Perf) ---------- */
function dominatesPerf(a, b){
  // a dominates b if a is >= on all ‚Äúgood‚Äù metrics and <= on trades, with at least one strict improvement
  const hi = ["total_pnl_bps","avg_pnl_bps","med_pnl_bps","win_pct"];
  const lo = ["trades"];

  let geAll = true;
  let gtAny = false;

  for(const k of hi){
    const va = +a[k], vb = +b[k];
    if(!(va >= vb)) geAll = false;
    if(va > vb) gtAny = true;
  }
  for(const k of lo){
    const va = +a[k], vb = +b[k];
    if(!(va <= vb)) geAll = false;
    if(va < vb) gtAny = true;
  }
  return geAll && gtAny;
}
function filterDominatedPerf(rows){
  return rows.filter(r => !rows.some(o => o !== r && dominatesPerf(o, r)));
}

/* ---------- recompute ---------- */
function recomputeScoresAndNormalize(){
  if(!lastRows || !lastRows.length) return;

  _ensureDDScale(lastRows);
  _ensureSharpePresent(lastRows);

  const RS = {
    Sharpe: _robustStats(lastRows, 'Sharpe'),
    MaxDD:  _robustStats(lastRows, 'MaxDD'),
    trades: _robustStats(lastRows, 'trades')
  };

  const PS = {
    total_pnl_bps: _robustStats(lastRows, 'total_pnl_bps'),
    avg_pnl_bps:   _robustStats(lastRows, 'avg_pnl_bps'),
    med_pnl_bps:   _robustStats(lastRows, 'med_pnl_bps'),
    win_pct:       _robustStats(lastRows, 'win_pct'),
    trades:        _robustStats(lastRows, 'trades')
  };

  const W = riskWeights(+document.getElementById('risk').value);
  const P = perfWeights(+document.getElementById('perf').value);

  lastRows.forEach(r=>{
    r._riskRaw = scoreRisk(r, W, RS);
    r._perfRaw = scorePerf(r, P, PS);
  });

  // normalizeRank0_10(lastRows, '_riskRaw', 'riskScoreN');
  // normalizeRank0_10(lastRows, '_perfRaw', 'perfScoreN');
  normalizeRobust0_10(lastRows, '_riskRaw', 'riskScoreN');
  normalizeRobust0_10(lastRows, '_perfRaw', 'perfScoreN');

  // ‚úÖ Debug logs (include 2000 / 1800000 / 3600000 etc)
  const dbg = [2000, 5000, 10000, 1200000, 1800000, 3600000];
  dbg.forEach(h=>{
    const r = lastRows.find(x=>x.h_ms===h);
    if(!r) return;
    console.log("[SCORE DBG]", h, {
      Sharpe:r.Sharpe, MaxDD:r.MaxDD, trades:r.trades,
      total:r.total_pnl_bps, avg:r.avg_pnl_bps, med:r.med_pnl_bps, win:r.win_pct,
      riskRaw:r._riskRaw, riskN:r.riskScoreN,
      perfRaw:r._perfRaw, perfN:r.perfScoreN
    });
  });
}

/* ------------------------ Chart builders ------------------------ */
function commonOptions(){
  return {
    responsive:true, maintainAspectRatio:false,
    layout:{padding:{top:0,right:0,bottom:0,left:0}},
    plugins:{legend:{display:true, position:'top', labels:{boxWidth:10}}},
    scales:{x:{grid:{display:false}}, y:{beginAtZero:true}}
  };
}
function makeBarChart(ctx, labels, data, label, color){
  return new Chart(ctx,{ type:'bar',
    data:{ labels, datasets:[{ label, data, backgroundColor: color, borderColor: color, borderWidth: 1 }]},
    options: commonOptions()
  });
}
function makeLineChart(ctx, labels, data, label, color){
  return new Chart(ctx,{ type:'line',
    data:{ labels, datasets:[{ label, data, borderColor: color, backgroundColor: color, borderWidth: 2, pointRadius:2, tension:0.25, fill:false }]},
    options: commonOptions()
  });
}

/* ------------------------ Performance panel ------------------------ */
function buildAnchorChecksPerf(rows){
  const wrap = document.getElementById('anchorChecks');
  wrap.innerHTML = rows.map(r => `<label><input type="checkbox" class="anchorChk" value="${r.h_ms}" checked> ${r.h_ms} ms</label>`).join('');
  wrap.querySelectorAll('.anchorChk').forEach(cb=> cb.addEventListener('change', ()=>{ updatePerfChart(); syncChartCardHeights(); }));
  document.getElementById('anchorsAll').onclick  = (e)=>{ e.preventDefault(); wrap.querySelectorAll('.anchorChk').forEach(c=>c.checked=true);  updatePerfChart(); syncChartCardHeights(); };
  document.getElementById('anchorsNone').onclick = (e)=>{ e.preventDefault(); wrap.querySelectorAll('.anchorChk').forEach(c=>c.checked=false); updatePerfChart(); syncChartCardHeights(); };
  document.getElementById('metricSel').onchange = ()=>{ updatePerfChart(); syncChartCardHeights(); };
}
function getSelectedPerfAnchors(){ return Array.from(document.querySelectorAll('.anchorChk')).filter(c=>c.checked).map(c=>+c.value); }
function updatePerfChart(){
  if(!lastRows.length) return;
  recomputeScoresAndNormalize();
  const metric = document.getElementById('metricSel').value;
  const sel = new Set(getSelectedPerfAnchors());
  const rows = lastRows.filter(r => sel.has(r.h_ms));
  const labels = rows.map(r=>r.h_ms+' ms');
  const data = rows.map(r => r[metric]);
  const color = METRIC_COLORS[metric] || '#7aa2ff';
  if(pnlChart){ pnlChart.destroy(); }
  pnlChart = makeBarChart(document.getElementById('pnlChart').getContext('2d'), labels, data, metric, color);
  renderTables(); updateRecommendations();
}

/* ------------------------ Risk panel ------------------------ */
function buildAnchorChecksRisk(rows){
  const wrap = document.getElementById('anchorChecksRisk');
  wrap.innerHTML = rows.map(r => `<label><input type="checkbox" class="riskAnchorChk" value="${r.h_ms}" checked> ${r.h_ms} ms</label>`).join('');
  wrap.querySelectorAll('.riskAnchorChk').forEach(cb=> cb.addEventListener('change', ()=>{ updateRiskChart(); syncChartCardHeights(); }));
  document.getElementById('riskAnchorsAll').onclick  = (e)=>{ e.preventDefault(); wrap.querySelectorAll('.riskAnchorChk').forEach(c=>c.checked=true);  updateRiskChart(); syncChartCardHeights(); };
  document.getElementById('riskAnchorsNone').onclick = (e)=>{ e.preventDefault(); wrap.querySelectorAll('.riskAnchorChk').forEach(c=>c.checked=false); updateRiskChart(); syncChartCardHeights(); };
  document.getElementById('riskMetricSel').onchange = ()=>{ updateRiskChart(); syncChartCardHeights(); };
}
function getSelectedRiskAnchors(){ return Array.from(document.querySelectorAll('.riskAnchorChk')).filter(c=>c.checked).map(c=>+c.value); }
function updateRiskChart(){
  if(!lastRows.length) return;
  recomputeScoresAndNormalize();
  const metric = document.getElementById('riskMetricSel').value;
  const sel = new Set(getSelectedRiskAnchors());
  const rows = lastRows.filter(r => sel.has(r.h_ms));
  const labels = rows.map(r=>r.h_ms+' ms');
  const data = rows.map(r => r[metric]);
  const color = METRIC_COLORS[metric] || '#7aa2ff';
  if(riskChart){ riskChart.destroy(); }
  riskChart = makeLineChart(document.getElementById('riskChart').getContext('2d'), labels, data, metric, color);
  renderTables(); updateRecommendations();
}

/* ------------------------ Tables + Recs ------------------------ */
function renderTables(){
  const rt=document.querySelector('#riskTable tbody');
  rt.innerHTML = lastRows.map(r=>`
    <tr>
      <td>${r.h_ms}</td>
      <td class="num">${Number.isFinite(r.tau)?r.tau.toFixed(3):'‚Äî'}</td>
      <td class="num">${Number.isFinite(r.q)?r.q.toFixed(2):'‚Äî'}</td>
      <td class="num">${num(r.Sharpe,0).toFixed(3)}</td>
      <td class="num">${num(r.Turnover,0)}</td>
      <td class="num">${num(r.MaxDD,0).toFixed(3)}</td>
      <td class="num">${num(r.Utility,0).toFixed(3)}</td>
      <td class="num">${num(r.riskScoreN,0).toFixed(2)}</td>
    </tr>`).join('');

  const st=document.querySelector('#simTable tbody');
  st.innerHTML = lastRows.map(r=>`
    <tr>
      <td>${r.h_ms}</td>
      <td class="num">${num(r.trades,0)}</td>
      <td class="num"><span class="pnlChip">${num(r.total_pnl_bps,0).toFixed(3)}</span></td>
      <td class="num">${num(r.avg_pnl_bps,0).toFixed(3)}</td>
      <td class="num">${num(r.med_pnl_bps,0).toFixed(3)}</td>
      <td class="num">${num(r.profit_trades,0)}</td>
      <td class="num">${num(r.losing_trades,0)}</td>
      <td class="num">${num(r.flat,0)}</td>
      <td class="num">${num(r.win_pct,0).toFixed(1)}</td>
      <td class="num">${num(r.perfScoreN,0).toFixed(2)}</td>
    </tr>`).join('');
}

/* ------------------------ Recommendations (TOP-K MODULE) ------------------------ */
function updateRecommendations(){
  const topk = +document.getElementById('topk').value || 3;

  // Make sure scores exist
  recomputeScoresAndNormalize();

  // Risk: sort by riskScoreN, tie-break by lower DD then higher Sharpe then lower trades
  const topRisk = lastRows.slice()
    .sort((a,b)=>
      (b.riskScoreN - a.riskScoreN) ||
      ((+a.MaxDD||0) - (+b.MaxDD||0)) ||
      ((+b.Sharpe||-1e9) - (+a.Sharpe||-1e9)) ||
      ((+a.trades||0) - (+b.trades||0))
    )
    .slice(0, topk);

  // Perf: dominance filter first (intuition), then score, then tie-breakers
  const perfPool = filterDominatedPerf(lastRows.slice());

  const topPerf = perfPool
    .sort((a,b)=>
      (b.perfScoreN - a.perfScoreN) ||
      ((+b.total_pnl_bps||0) - (+a.total_pnl_bps||0)) ||
      ((+b.avg_pnl_bps||0)   - (+a.avg_pnl_bps||0)) ||
      ((+b.win_pct||0)       - (+a.win_pct||0)) ||
      ((+a.trades||0)        - (+b.trades||0))
    )
    .slice(0, topk);

  document.getElementById('recsRisk').innerHTML =
    topRisk.map((r,i)=>`<span class="pill ${i===0?'good':'warn'}">${r.h_ms} ms ‚Ä¢ ${r.riskScoreN.toFixed(2)}</span>`).join('');

  document.getElementById('recsPerf').innerHTML =
    topPerf.map((r,i)=>`<span class="pill ${i===0?'good':'alt'}">${r.h_ms} ms ‚Ä¢ ${r.perfScoreN.toFixed(2)}</span>`).join('');

  // Console audit (exactly what you printed earlier)
  console.log("üèÅ TOP-K");
  console.table(topRisk.map(r=>({
    h_ms:r.h_ms, riskScoreN:+r.riskScoreN.toFixed(2), _riskRaw:+r._riskRaw.toFixed(4),
    Sharpe:r.Sharpe, trades:r.trades, MaxDD:r.MaxDD
  })));
  console.table(topPerf.map(r=>({
    h_ms:r.h_ms, perfScoreN:+r.perfScoreN.toFixed(2), _perfRaw:+r._perfRaw.toFixed(4),
    total:r.total_pnl_bps, avg:r.avg_pnl_bps, med:r.med_pnl_bps, win:r.win_pct, trades:r.trades
  })));
}

/* ------------------------ Font size sync (tables) ------------------------ */
function scaleForWidth(px){ if(px <= 420) return 11; if(px <= 560) return 12; if(px <= 720) return 13; return 14; }
function syncTableFontSizes(){
  const riskCanvas = document.getElementById('riskChart');
  const pnlCanvas  = document.getElementById('pnlChart');
  if(riskCanvas){
    const w = riskCanvas.getBoundingClientRect().width || 600;
    document.getElementById('riskTable').style.fontSize = scaleForWidth(w) + 'px';
  }
  if(pnlCanvas){
    const w = pnlCanvas.getBoundingClientRect().width || 600;
    document.getElementById('simTable').style.fontSize  = scaleForWidth(w) + 'px';
  }
}

/* ------------------------ Render ------------------------ */
async function render(){
  const asof = document.getElementById('asof').value;
  const sym  = document.getElementById('instrument').value;
  const tag  = document.getElementById('tagSel').value;

  const key = `${asof}_${sym}_${tag}`;
  const seq = ++renderSeq; currentKey = key;

  if(pnlChart){ pnlChart.destroy(); pnlChart = null; }
  if(riskChart){ riskChart.destroy(); riskChart = null; }

  document.querySelector('#riskTable tbody').innerHTML = '';
  document.querySelector('#simTable tbody').innerHTML = '';
  document.getElementById('recsRisk').innerHTML = '';
  document.getElementById('recsPerf').innerHTML = '';
  document.getElementById('anchorChecks').innerHTML = '';
  document.getElementById('anchorChecksRisk').innerHTML = '';
  document.getElementById('status').textContent = '';

  if(!cache[key]){
    cache[key] = buildRowsFor(asof, sym, tag);
  }
  if(seq !== renderSeq || key !== currentKey) return;

  const built = cache[key];
  lastRows = (built.rows || []).slice().sort((a,b)=>a.h_ms-b.h_ms);

  if(!lastRows.length){
    document.getElementById('recsRisk').innerHTML =
      `<span class="pill warn">No data for ${sym} ‚Ä¢ ${asof} ‚Ä¢ ${tag}</span>`;
    document.getElementById('status').textContent =
      `Source: ${JSON_URL} ‚Ä¢ No rows for ${sym} ${asof} ${tag}`;
    return;
  }

  recomputeScoresAndNormalize();
  buildAnchorChecksRisk(lastRows); updateRiskChart();
  buildAnchorChecksPerf(lastRows); updatePerfChart();
  renderTables(); updateRecommendations(); syncTableFontSizes(); syncChartCardHeights();

  const dupMsg = (built.meta && built.meta.dup_horizons > 0)
    ? ` ‚Ä¢ WARNING: dup_horizons=${built.meta.dup_horizons}`
    : '';
  document.getElementById('status').textContent =
    `Source: ${JSON_URL} ‚Ä¢ ${sym} ‚Ä¢ asof=${asof} ‚Ä¢ tag=${tag} ‚Ä¢ rows=${lastRows.length}${dupMsg}`;
}

/* events */
['asof','instrument','tagSel','topk'].forEach(id=>{
  document.getElementById(id).addEventListener('change', ()=>{
    render();
    setTimeout(syncChartCardHeights,0);
  });
});
['risk','perf'].forEach(id=>{
  document.getElementById(id).addEventListener('input', ()=>{
    if(!lastRows.length) return;
    updateRiskChart();
    updatePerfChart();
    syncTableFontSizes();
    syncChartCardHeights();
  });
});
window.addEventListener('resize', ()=>{ syncTableFontSizes(); syncChartCardHeights(); });

/* boot */
(async function boot(){
  try{
    RAW = await loadJSON();
    RAW.forEach(r => {
      if(r.symbol) r.symbol = String(r.symbol).toUpperCase();
      if(r.tag) r.tag = String(r.tag).toUpperCase();
    });

    populateAsofs();

    // If JSON has only OS initially, keep OS selected
    const tags = Array.from(new Set(RAW.map(r=>String(r.tag||"").toUpperCase()).filter(Boolean)));
    if(tags.includes("IS") && tags.includes("OS")){
      // keep default OS
    }else if(tags.length === 1){
      document.getElementById('tagSel').value = tags[0];
    }

    render();
  }catch(e){
    document.getElementById('recsRisk').innerHTML = `<span class="pill warn">${e?.message || e}</span>`;
    document.getElementById('status').textContent = `Load error: ${e?.message || e}`;
  }
})();

</script>
</body>
</html>
