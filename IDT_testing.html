<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>

<title>Quantum Yield IDT Trading In-sample and Out-of-sample Weekly Report</title>

<style>
:root{
  --bg:#0b0f14;
  --panel:#111826;
  --muted:#94a3b8;
  --text:#e5e7eb;
  --accent:#38bdf8;
}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  background:var(--bg);
  color:var(--text);
}
.wrap{max-width:1480px;margin:0 auto;padding:16px}

/* ===== Header ===== */
.hdr{
  display:flex;
  align-items:center;
  justify-content:flex-start;
  gap:16px;
  padding:12px 16px;
  margin-bottom:14px;
  background:linear-gradient(180deg,#0f172a,#0b0f14);
  border:1px solid rgba(148,163,184,.18);
  border-radius:16px;
}
.brand{
  display:flex;
  align-items:center;
  gap:14px;
}
.brand img{
  height:40px;
  width:auto;
  border-radius:8px;
}
.brand h1{
  margin:0;
  font-size:18px;
  font-weight:600;
  color:var(--text);
  letter-spacing:.2px;
}

/* ===== Panels / Controls ===== */
.panel{
  background:var(--panel);
  border:1px solid rgba(148,163,184,.18);
  border-radius:14px;
  padding:14px;
  margin-bottom:12px;
}
.row{
  display:flex;
  gap:12px;
  flex-wrap:wrap;
  align-items:flex-end;
}

/* make label blocks behave consistently */
.ctrl{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.ctrl label{
  font-size:12px;
  color:var(--muted);
  margin-left:2px;
}
select,button{
  background:#0f172a;
  color:var(--text);
  border:1px solid rgba(148,163,184,.25);
  border-radius:10px;
  padding:10px 12px;
  font-size:14px;
}
button{cursor:pointer}
button:hover{border-color:var(--accent)}
.hint{color:var(--muted);font-size:12px;margin-top:6px}

/* 2:1 ratio (chart wider) */
.grid{display:grid;grid-template-columns:2fr 1fr;gap:12px}
@media(max-width:980px){.grid{grid-template-columns:1fr}}

.chartWrap{position:relative}
svg{
  width:100%;
  height:470px;
  background:#0f172a;
  border-radius:12px;
  border:1px solid rgba(148,163,184,.15);
  overflow:visible;
}
.kv{display:grid;grid-template-columns:190px 1fr;gap:8px;font-size:14px}
.kv div:nth-child(odd){color:var(--muted)}

.hzBox{
  display:flex;
  gap:14px;
  align-items:flex-start;
  flex-wrap:wrap;
}

/* horizons: ✅ 3 columns */
.hzList{
  background:#0f172a;
  border:1px solid rgba(148,163,184,.25);
  border-radius:12px;
  padding:10px;

  max-height:none;
  overflow:visible;

  min-width:740px;

  display:grid;
  grid-template-columns:repeat(3, minmax(210px, 1fr));
  column-gap:18px;
  row-gap:6px;
}
@media (max-width: 1100px){
  .hzList{
    grid-template-columns:repeat(2, minmax(220px, 1fr));
    min-width:560px;
  }
}

.hzItem{
  display:flex;
  align-items:center;
  gap:8px;
  padding:2px 0;
  font-size:13px;
  color:var(--text);
  white-space:nowrap;
}

/* metric checkboxes */
.metricList{
  background:#0f172a;
  border:1px solid rgba(148,163,184,.25);
  border-radius:12px;
  padding:10px;

  min-width:320px;
  max-height:160px;
  overflow:auto;

  display:grid;
  grid-template-columns:repeat(2, minmax(140px, 1fr));
  column-gap:14px;
  row-gap:6px;
}
.metricItem{
  display:flex;
  align-items:center;
  gap:8px;
  font-size:13px;
  white-space:nowrap;
}

.swatch{
  width:10px;height:10px;border-radius:3px;display:inline-block;
  border:1px solid rgba(148,163,184,.35);
}
.legend{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  margin-top:8px;
  color:var(--muted);
  font-size:12px;
}
.legendItem{
  display:flex;align-items:center;gap:8px;
  padding:6px 8px;
  border-radius:999px;
  background:rgba(148,163,184,.08);
  border:1px solid rgba(148,163,184,.12);
}
.tooltip{
  position:absolute;
  pointer-events:none;
  display:none;
  z-index:10;
  background:#0b1220;
  border:1px solid rgba(148,163,184,.25);
  border-radius:10px;
  padding:8px 10px;
  font-size:12px;
  color:var(--text);
  box-shadow:0 6px 18px rgba(0,0,0,.35);
  max-width:340px;
  white-space:nowrap;
}
.muted{color:var(--muted)}

/* quick range buttons */
.btnRow{
  display:flex;
  gap:8px;
  align-items:flex-end;
}
.btnPill{
  padding:9px 12px;
  border-radius:12px;
  font-weight:600;
}
.btnPill.active{
  border-color:rgba(56,189,248,.7);
  box-shadow:0 0 0 2px rgba(56,189,248,.15) inset;
}
</style>
</head>

<body>
<div class="wrap">

  <!-- ===== Header ===== -->
  <div class="hdr">
    <div class="brand">
      <a href="https://quantumyield.ai" target="_blank" rel="noopener">
        <img src="https://quantumyield.ai/logo.jpg" alt="Quantum Yield Logo">
      </a>
      <h1 id="pageTitle">Quantum Yield Intra-Day-Trading In-sample & Out-of-sample Daily Report</h1>
    </div>
  </div>

  <!-- ===== Controls ===== -->
  <div class="panel">
    <div class="row">

      <div class="ctrl">
        <label>Symbol</label>
        <select id="sym"></select>
      </div>

      <div class="ctrl">
        <label>IS/OS</label>
        <select id="tag"><option>IS</option><option>OS</option></select>
      </div>

      <div class="ctrl">
        <label>Date start</label>
        <select id="dateStart"></select>
      </div>

      <div class="ctrl">
        <label>Date end</label>
        <select id="dateEnd"></select>
      </div>

      <div class="btnRow">
        <button id="btnAll" class="btnPill">All</button>
        <button id="btnLast5" class="btnPill">Last 5</button>
        <button id="btnLast10" class="btnPill">Last 10</button>
      </div>

      <!-- ✅ Horizons + Metrics on SAME row -->
      <div class="hzBox" style="width:100%; align-items:stretch;">

        <!-- Horizons -->
        <div style="flex:1; min-width:740px;">
          <div class="muted" style="font-size:12px;margin:0 0 6px 2px;">Horizons (multi)</div>
          <div id="hzList" class="hzList" style="min-width:0; width:100%;"></div>
        </div>

        <!-- Metrics -->
        <div style="flex:0 0 420px; min-width:420px;">
          <div class="muted" style="font-size:12px;margin:0 0 6px 2px;">Metrics (multi)</div>
          <div class="row" style="gap:8px;align-items:flex-start;">
            <div id="metricList" class="metricList" style="min-width:0; width:100%;"></div>
            <div style="display:flex; flex-direction:column; gap:8px;">
              <button id="metricsAll">All</button>
              <button id="metricsNone">None</button>
            </div>
          </div>
          <div class="hint">Metrics are auto-assigned to left/right Y-axis by range. Right-axis metrics render as bars (colored by horizon).</div>
        </div>

      </div>
    </div>

    <div class="hint" id="status"></div>
    <div class="legend" id="legend"></div>
  </div>

  <div class="grid">
    <div class="panel">
      <div style="color:var(--muted);font-weight:600;margin-bottom:6px">
        Trend (by day)
      </div>
      <div class="chartWrap">
        <svg id="chart" viewBox="0 0 1200 470" preserveAspectRatio="none"></svg>
        <div id="tooltip" class="tooltip"></div>
      </div>
      <div class="hint">
        X = date (asof). Left/Right Y-axes are auto-scaled by metric range. Color = horizon.
      </div>
    </div>

    <div class="panel">
      <div style="color:var(--muted);font-weight:600;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center;gap:10px;">
        <span>Snapshot metrics (first selected horizon)</span>
        <span style="display:flex;align-items:center;gap:8px;">
          <span class="muted" style="font-size:12px;">Snapshot date</span>
          <select id="snapDate" style="padding:8px 10px;font-size:13px;"></select>
        </span>
      </div>
      <div class="kv" id="kpi"></div>
    </div>
  </div>

</div>

<script>
let DATA = [];
let METRICS = [];
const $ = id => document.getElementById(id);

const COLORS = [
  "#38bdf8", "#a78bfa", "#34d399", "#fb7185", "#fbbf24",
  "#22c55e", "#60a5fa", "#f472b6", "#c084fc", "#f97316",
  "#2dd4bf", "#e879f9"
];

// dash patterns by horizon (repeats if many horizons)
const DASHES = ["", "8 4", "4 3", "12 4 2 4", "2 3", "10 3"];

// Metric order (extend to include newer JSON fields too)
const METRIC_ORDER = [
  // core distribution
  "count","mean_all_bps","std_all_bps","median_bps","p5_bps","p95_bps","min_bps","max_bps",
  // trade counts / breakdown
  "num_trades","num_longs","num_shorts","mean_trades_bps","mean_long_bps","mean_short_bps",
  "win_rate","long_win_rate","short_win_rate",
  // risk-like
  "sharpe","sortino","kelly",
  // new / added
  "Turnover","MaxDD","Utility",
  // sometimes present in other builds
  "total_pnl_bps","avg_pnl_bps","med_pnl_bps","win_pct","trades","profit_trades","losing_trades","flat",
  "riskScoreN","perfScoreN"
];

function uniq(a){ return [...new Set(a)]; }
function fmt(x){
  if(x===null||x===undefined||x==="") return "—";
  if(typeof x==="number"){
    if(!Number.isFinite(x)) return "—";
    return Math.abs(x)>=1000 ? x.toFixed(0)
      : x.toFixed(6).replace(/0+$/,"").replace(/\.$/,"");
  }
  return String(x);
}
function status(s){ $("status").textContent=s; }

function horizonLabel(ms){
  const s = ms/1000;
  if(s < 60) return `${Math.round(s)}s`;
  const m = s/60;
  if(m < 60) return `${Math.round(m)}m`;
  return `${Math.round(m/60)}h`;
}

function selection(){
  const sym = $("sym").value;
  const tag = $("tag").value;

  const hz = [...document.querySelectorAll('input[name="hzcb"]:checked')].map(el => Number(el.value));
  hz.sort((a,b)=>a-b);

  const metrics = [...document.querySelectorAll('input[name="metriccb"]:checked')].map(el => el.value);

  const ds = $("dateStart").value;
  const de = $("dateEnd").value;

  return { sym, tag, metrics, horizons: hz, dateStart: ds, dateEnd: de };
}

/* ---------- dates helpers (per sym/tag) ---------- */
function allDatesFor(sym, tag){
  return uniq(DATA.filter(d => d.symbol===sym && d.tag===tag).map(d => d.asof)).sort();
}
function clampEndGteStart(){
  const ds = $("dateStart").value;
  const de = $("dateEnd").value;
  if(de < ds){
    $("dateEnd").value = ds;
  }
}
function filteredDates(sym, tag){
  const ds = $("dateStart").value;
  const de = $("dateEnd").value;
  const all = allDatesFor(sym, tag);
  return all.filter(d => d >= ds && d <= de);
}

/* ---------- selectors ---------- */
function buildSelectors(){
  const syms = uniq(DATA.map(d=>d.symbol)).sort();
  $("sym").innerHTML = syms.map(s=>`<option>${s}</option>`).join("");
  $("sym").value = syms.includes("ES") ? "ES" : syms[0];
  refreshAllForSymTag(true);
}

function refreshAllForSymTag(resetQuickButtons){
  const sym = $("sym").value;
  const tag = $("tag").value;

  const dates = allDatesFor(sym, tag);
  $("dateStart").innerHTML = dates.map(d=>`<option value="${d}">${d}</option>`).join("");
  $("dateEnd").innerHTML   = dates.map(d=>`<option value="${d}">${d}</option>`).join("");

  if(dates.length){
    $("dateStart").value = dates[0];
    $("dateEnd").value = dates[dates.length-1];
  }

  if(resetQuickButtons){
    setQuickActive("all");
  }

  refreshHZMetric();
}

/* ---------- horizon color mapping (based on ALL horizons sorted) ---------- */
function getAllHzSorted(sym, tag){
  const rowsForHzIndex = DATA.filter(d=>d.symbol===sym && d.tag===tag);
  return uniq(rowsForHzIndex.map(d=>d.horizon_ms)).sort((a,b)=>a-b);
}
function colorForHz(sym, tag, hz){
  const allHzSorted = getAllHzSorted(sym, tag);
  const hzIdx = allHzSorted.indexOf(hz);
  return COLORS[(hzIdx >= 0 ? hzIdx : 0) % COLORS.length];
}
function dashForHz(sym, tag, hz){
  const allHzSorted = getAllHzSorted(sym, tag);
  const hzIdx = allHzSorted.indexOf(hz);
  return DASHES[(hzIdx >= 0 ? hzIdx : 0) % DASHES.length];
}
function updateHorizonSwatches(){
  const sym = $("sym").value;
  const tag = $("tag").value;

  document.querySelectorAll('input[name="hzcb"]').forEach(cb=>{
    const hz = Number(cb.value);
    const sw = cb.closest("label")?.querySelector(".swatch");
    if(!sw) return;
    sw.style.background = cb.checked ? colorForHz(sym, tag, hz) : "rgba(148,163,184,.25)";
  });
}

/* ---------- horizons + metrics ---------- */
function refreshHZMetric(){
  const sym = $("sym").value;
  const tag = $("tag").value;
  const rows = DATA.filter(d=>d.symbol===sym && d.tag===tag);

  // horizons
  const hzs = uniq(rows.map(d=>d.horizon_ms)).sort((a,b)=>a-b);
  const hzList = $("hzList");
  hzList.innerHTML = "";

  const defaultPick = new Set(hzs.slice(Math.max(0, hzs.length-5))); // last 5 by default

  hzs.forEach((h) => {
    const line = document.createElement("label");
    line.className = "hzItem";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.name = "hzcb";
    cb.value = String(h);
    cb.checked = defaultPick.has(h);
    cb.addEventListener("change", () => {
      updateHorizonSwatches();
      render();
    });

    const sw = document.createElement("span");
    sw.className = "swatch";
    sw.style.background = cb.checked ? colorForHz(sym, tag, h) : "rgba(148,163,184,.25)";

    const txt = document.createElement("span");
    txt.textContent = `${h} (${horizonLabel(h)})`;

    line.appendChild(cb);
    line.appendChild(sw);
    line.appendChild(txt);
    hzList.appendChild(line);
  });

  // metrics
  METRICS = METRIC_ORDER.filter(k => rows.some(r => Number.isFinite(Number(r[k]))));

  const metricList = $("metricList");
  metricList.innerHTML = "";

  const defaultMetricPick = new Set();
  if (METRICS.includes("win_rate")) defaultMetricPick.add("win_rate");
  else if (METRICS[0]) defaultMetricPick.add(METRICS[0]);

  METRICS.forEach((m) => {
    const line = document.createElement("label");
    line.className = "metricItem";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.name = "metriccb";
    cb.value = m;
    cb.checked = defaultMetricPick.has(m);
    cb.addEventListener("change", () => render());

    const sw = document.createElement("span");
    sw.className = "swatch";
    sw.style.background = "rgba(148,163,184,.25)"; // metric swatch not used for meaning

    const txt = document.createElement("span");
    txt.textContent = m;

    line.appendChild(cb);
    line.appendChild(sw);
    line.appendChild(txt);
    metricList.appendChild(line);
  });

  $("metricsAll").onclick = () => {
    metricList.querySelectorAll('input[name="metriccb"]').forEach(c => c.checked = true);
    render();
  };
  $("metricsNone").onclick = () => {
    metricList.querySelectorAll('input[name="metriccb"]').forEach(c => c.checked = false);
    render();
  };

  updateHorizonSwatches();
  render();
}

/* ---------- quick buttons ---------- */
function setQuickActive(which){
  ["btnAll","btnLast5","btnLast10"].forEach(id=>$(id).classList.remove("active"));
  if(which==="all") $("btnAll").classList.add("active");
  if(which==="last5") $("btnLast5").classList.add("active");
  if(which==="last10") $("btnLast10").classList.add("active");
}

function applyRangeLastN(n){
  const sym = $("sym").value;
  const tag = $("tag").value;
  const dates = allDatesFor(sym, tag);
  if(!dates.length) return;

  const start = dates[Math.max(0, dates.length - n)];
  const end = dates[dates.length - 1];

  $("dateStart").value = start;
  $("dateEnd").value = end;
  clampEndGteStart();
  render();
}

/* ---------- ticks ---------- */
function niceTicks(min, max, n=6){
  const span = max - min;
  if(!Number.isFinite(span) || span === 0){
    const v = Number.isFinite(min) ? min : 0;
    return { min: v-1, max: v+1, ticks: [v-1, v, v+1] };
  }
  const rawStep = span / (n-1);
  const pow = Math.pow(10, Math.floor(Math.log10(rawStep)));
  const err = rawStep / pow;
  let step = pow;
  if(err >= 5) step = 5*pow;
  else if(err >= 2) step = 2*pow;

  const niceMin = Math.floor(min/step)*step;
  const niceMax = Math.ceil(max/step)*step;

  const ticks = [];
  for(let v=niceMin; v<=niceMax + step/2; v+=step) ticks.push(v);
  return { min: niceMin, max: niceMax, ticks };
}

/* ---------- snapshot date list ---------- */
function refreshSnapDateList(datesInRange){
  const prev = $("snapDate").value;
  $("snapDate").innerHTML = datesInRange.map(d=>`<option value="${d}">${d}</option>`).join("");
  if(prev && datesInRange.includes(prev)){
    $("snapDate").value = prev;
  } else if(datesInRange.length){
    $("snapDate").value = datesInRange[datesInRange.length-1];
  }
}

/* ---------- invariant detector (per metric) ---------- */
function metricLooksInvariant(sym, tag, metric, horizons, dates){
  if(!horizons.length || !dates.length) return false;
  for(const dt of dates){
    let v0 = null; let set0 = false;
    for(const hz of horizons){
      const row = DATA.find(d => d.symbol===sym && d.tag===tag && d.horizon_ms===hz && d.asof===dt);
      const v = row ? Number(row[metric]) : NaN;
      if(!Number.isFinite(v)) continue;
      if(!set0){ v0 = v; set0 = true; }
      else if(Math.abs(v - v0) > 1e-12) return false;
    }
  }
  return true;
}

/* ---------- axis assignment: split metrics into Left/Right by range ---------- */
function splitMetricsByRange(sym, tag, metrics, horizons, dates){
  const spanByMetric = new Map();
  for(const metric of metrics){
    let minV = Infinity, maxV = -Infinity;
    for(const hz of horizons){
      for(const dt of dates){
        const row = DATA.find(d => d.symbol===sym && d.tag===tag && d.horizon_ms===hz && d.asof===dt);
        const v = row ? Number(row[metric]) : NaN;
        if(!Number.isFinite(v)) continue;
        if(v < minV) minV = v;
        if(v > maxV) maxV = v;
      }
    }
    const span = (minV===Infinity) ? 0 : (maxV - minV);
    spanByMetric.set(metric, span);
  }

  if(metrics.length <= 1){
    return { left: metrics.slice(), right: [], spanByMetric };
  }

  const spans = metrics.map(m => Math.max(0, spanByMetric.get(m) || 0)).filter(s => Number.isFinite(s));
  const nonZero = spans.filter(s => s > 0);
  if(nonZero.length <= 1){
    return { left: metrics.slice(), right: [], spanByMetric };
  }

  const minSpan = Math.min(...nonZero);
  const maxSpan = Math.max(...nonZero);

  const ratio = maxSpan / minSpan;
  if(ratio < 8){
    return { left: metrics.slice(), right: [], spanByMetric };
  }

  const threshold = Math.sqrt(minSpan * maxSpan);

  const left = [];
  const right = [];
  for(const m of metrics){
    const s = spanByMetric.get(m) || 0;
    (s >= threshold ? left : right).push(m);
  }

  if(!left.length) { left.push(right.shift()); }
  if(!right.length) { right.push(left.pop()); }

  return { left, right, spanByMetric };
}

/* ---------- legend: COLOR = HORIZON (consistent across metrics) ---------- */
function renderLegend(metricsLeft, metricsRight, horizons){
  const legend = $("legend");
  legend.innerHTML = "";

  const sym = $("sym").value;
  const tag = $("tag").value;

  horizons.forEach(hz=>{
    const color = colorForHz(sym, tag, hz);

    const item = document.createElement("div");
    item.className = "legendItem";

    const sw = document.createElement("span");
    sw.className = "swatch";
    sw.style.background = color;

    const tx = document.createElement("span");
    tx.textContent = `hz=${hz} (${horizonLabel(hz)})`;

    item.appendChild(sw);
    item.appendChild(tx);
    legend.appendChild(item);
  });

  const note = document.createElement("div");
  note.className = "legendItem";
  note.innerHTML = `<span class="muted">Color & dash = horizon • Axis side = metric scale • Right-axis metrics = bars only</span>`;
  legend.appendChild(note);
}

/* ---------- bars baseline: ALWAYS 0 line ---------- */
function barBaselineValue(){ return 0; }

/* ---------- render ---------- */
function render(){
  const {sym, tag, metrics, horizons} = selection();
  const svg = $("chart");
  const tip = $("tooltip");

  if(!metrics || !metrics.length){
    status("Select at least one metric checkbox.");
    $("legend").innerHTML = "";
    svg.innerHTML = "";
    $("kpi").innerHTML = "";
    return;
  }

  if(!horizons.length){
    status("Select at least one horizon checkbox.");
    $("legend").innerHTML = "";
    svg.innerHTML = "";
    $("kpi").innerHTML = "";
    return;
  }

  clampEndGteStart();
  const dates = filteredDates(sym, tag);
  if(!dates.length){
    status("No dates in selected range.");
    svg.innerHTML = "";
    $("kpi").innerHTML = "";
    $("snapDate").innerHTML = "";
    return;
  }

  refreshSnapDateList(dates);
  const dateIndex = new Map(dates.map((d,i)=>[d,i]));

  // split metrics into left / right by range (span)
  const split = splitMetricsByRange(sym, tag, metrics, horizons, dates);
  const metricsL = split.left;
  const metricsR = split.right;

  renderLegend(metricsL, metricsR, horizons);
  updateHorizonSwatches();

  // build series per (metric,horizon)
  const seriesMap = new Map(); // key = `${metric}__${hz}` -> pts
  metrics.forEach(metric => {
    horizons.forEach(hz => {
      const rows = DATA
        .filter(d => d.symbol===sym && d.tag===tag && d.horizon_ms===hz && d.asof >= dates[0] && d.asof <= dates[dates.length-1])
        .sort((a,b)=>a.asof.localeCompare(b.asof));

      const pts = rows.map(r => ({
        asof: r.asof,
        y: Number(r[metric]),
        raw: r
      })).filter(p => Number.isFinite(p.y));

      seriesMap.set(`${metric}__${hz}`, pts);
    });
  });

  // compute y ranges separately for left and right axes
  function collectY(metricsSide){
    const vals = [];
    for(const metric of metricsSide){
      for(const hz of horizons){
        const pts = seriesMap.get(`${metric}__${hz}`) || [];
        for(const p of pts) vals.push(p.y);
      }
    }
    return vals;
  }

  const yValsL = collectY(metricsL);
  const yValsR = collectY(metricsR);

  if(!yValsL.length && !yValsR.length){
    status(`No finite values to plot for ${sym} ${tag} in range.`);
    svg.innerHTML = "";
    $("kpi").innerHTML = "";
    return;
  }

  const hasL = yValsL.length > 0;
  const hasR = yValsR.length > 0;

  let yMinL=0, yMaxL=1, yTicksL=[0,1];
  let yMinR=0, yMaxR=1, yTicksR=[0,1];

  if(hasL){
    const min = Math.min(...yValsL), max = Math.max(...yValsL);
    const t = niceTicks(min, max, 6);
    yMinL = t.min; yMaxL = t.max; yTicksL = t.ticks;
  } else {
    const min = Math.min(...yValsR), max = Math.max(...yValsR);
    const t = niceTicks(min, max, 6);
    yMinL = t.min; yMaxL = t.max; yTicksL = t.ticks;
  }

  // ✅ Right axis ticks must be computed from right metrics ONLY; also ensure 0 is included for bar baseline
  if(hasR){
    const min = Math.min(...yValsR), max = Math.max(...yValsR);
    const min2 = Math.min(min, barBaselineValue());
    const max2 = Math.max(max, barBaselineValue());
    const t = niceTicks(min2, max2, 6);
    yMinR = t.min; yMaxR = t.max; yTicksR = t.ticks;
  }

  const W=1200, H=470;

  // ✅ keep BOTH Y-axes labels INSIDE chart area by padding + anchoring inside
  const m={l:88, r:(hasR?88:20), t:22, b:110}; // symmetric margins when right axis exists
  const pw=W-m.l-m.r, ph=H-m.t-m.b;

  const X = (date) => {
    const i = dateIndex.get(date);
    return m.l + pw * ((i ?? 0) / (dates.length-1 || 1));
  };

  const YL = (v) => m.t + ph * (1 - ((v - yMinL)/(yMaxL - yMinL || 1)));
  const YR = (v) => m.t + ph * (1 - ((v - yMinR)/(yMaxR - yMinR || 1)));

  // left gridlines + left ticks (labels INSIDE)
  const gridLinesL = yTicksL.map(v => {
    const y = YL(v);
    return `
      <line x1="${m.l}" x2="${W-m.r}" y1="${y}" y2="${y}" stroke="rgba(148,163,184,.10)" />
      <text x="${m.l+4}" y="${y+4}" text-anchor="start" font-size="11" fill="rgba(148,163,184,.85)">${fmt(v)}</text>
    `;
  }).join("");

  // right ticks (labels INSIDE)
  const ticksR = hasR ? yTicksR.map(v => {
    const y = YR(v);
    return `<text x="${W-m.r-4}" y="${y+4}" text-anchor="end" font-size="11" fill="rgba(148,163,184,.70)">${fmt(v)}</text>`;
  }).join("") : "";

  // x labels
  const xLabelY = (H - m.b) + 22;
  function md(d){
    if (typeof d === "string" && d.length === 8){
      return `${d.slice(4,6)}/${d.slice(6,8)}`;
    }
    return d;
  }
  function yyyy(d){
    return (typeof d === "string" && d.length === 8) ? d.slice(0,4) : "";
  }

  const chartPxW = svg.getBoundingClientRect().width || pw;
  const approxCharPx = 7.2;
  const sample = md(dates[Math.floor(dates.length/2)] || "");
  const approxLabelPx = Math.max(24, String(sample).length * approxCharPx);
  const minSpacingPx = approxLabelPx + 16;
  const maxLabels = Math.max(2, Math.min(8, Math.floor(chartPxW / minSpacingPx)));
  const step = Math.max(1, Math.ceil((dates.length - 2) / Math.max(1, (maxLabels - 2))));

  const xLabels = dates.map((d, i) => {
    const isEdge = (i === 0 || i === dates.length - 1);
    const isMilestone = ((i - 1) % step === 0);
    if (!isEdge && !isMilestone) return "";

    const x = X(d);
    const anchor = (i === 0) ? "start" : (i === dates.length - 1) ? "end" : "middle";

    return `
      <text x="${x}" y="${xLabelY}" text-anchor="${anchor}"
            font-size="12" fill="rgba(148,163,184,.95)">
        <tspan x="${x}" dy="0">${md(d)}</tspan>
        <tspan x="${x}" dy="14" font-size="11" fill="rgba(148,163,184,.75)">${yyyy(d)}</tspan>
      </text>
    `;
  }).join("");

  // ===== Bars (RIGHT-axis metrics): colored by horizon =====
  let bars = "";
  let barHitAreas = "";

  const rightMetrics = metricsR.slice();
  const nH = horizons.length;
  const nM = rightMetrics.length;
  const totalBars = Math.max(1, nH * nM);

  const dateStepPx = (dates.length > 1) ? (pw / (dates.length - 1)) : pw;
  const groupW = Math.max(12, Math.min(44, dateStepPx * 0.70));
  const gap = Math.max(1, Math.floor(groupW * 0.06));
  const barW = Math.max(2, Math.floor((groupW - gap * (totalBars - 1)) / totalBars));

  // ✅ baseline ALWAYS at 0
  const baseV = barBaselineValue();
  const yBase = YR(baseV);

  // cache value maps for right metrics to avoid rebuilding maps in loops
  const valueMap = new Map(); // key `${metric}__${hz}` -> Map(asof->y)
  for(const metric of rightMetrics){
    for(const hz of horizons){
      const pts = seriesMap.get(`${metric}__${hz}`) || [];
      valueMap.set(`${metric}__${hz}`, new Map(pts.map(p=>[p.asof,p.y])));
    }
  }

  rightMetrics.forEach((metric, mi) => {
    horizons.forEach((hz, hi) => {
      const color = colorForHz(sym, tag, hz);
      const op = Math.min(0.42, 0.22 + mi * 0.10);
      const slot = mi * nH + hi;
      const mm = valueMap.get(`${metric}__${hz}`) || new Map();

      for (let di = 0; di < dates.length; di++){
        const dt = dates[di];
        const v = mm.get(dt);
        if(!Number.isFinite(v)) continue;

        const xCenter = X(dt);
        const groupLeft = xCenter - Math.floor(groupW / 2);
        const x = groupLeft + slot * (barW + gap);

        const y = YR(v);
        const top = Math.min(y, yBase);
        const h = Math.max(1, Math.abs(yBase - y));

        bars += `
          <rect x="${x}" y="${top}" width="${barW}" height="${h}"
                fill="${color}" opacity="${op}"
                stroke="${color}" stroke-width="1"
                data-hz="${hz}"
                data-metric="${metric}"
                data-axis="R"
                data-type="bar"
                data-date="${dt}"
                data-val="${v}"></rect>
        `;

        barHitAreas += `
          <rect class="pt"
                x="${x-2}" y="${top}" width="${barW+4}" height="${h}"
                fill="transparent"
                data-hz="${hz}"
                data-metric="${metric}"
                data-axis="R"
                data-type="bar"
                data-date="${dt}"
                data-val="${v}"></rect>
        `;
      }
    });
  });

  // ✅ draw explicit zero baseline for right axis bars (inside chart area)
  const zeroLine = hasR ? `<line x1="${m.l}" x2="${W-m.r}" y1="${yBase}" y2="${yBase}" stroke="rgba(148,163,184,.22)" />` : "";

  // ===== Lines (LEFT-axis metrics ONLY): colored by horizon, dash by horizon =====
  // ✅ FIX: do NOT draw line for right-axis metrics (bars-only)
  let paths = "";
  let points = "";

  const lineMetrics = metrics.filter(met => !metricsR.includes(met)); // left-axis only

  lineMetrics.forEach((metric) => {
    horizons.forEach(hz => {
      const pts = seriesMap.get(`${metric}__${hz}`) || [];
      const color = colorForHz(sym, tag, hz);
      const dash = dashForHz(sym, tag, hz);

      const valByDate = new Map(pts.map(p => [p.asof, p.y]));
      let dPath = "";
      let started = false;

      for (const dt of dates) {
        const yv = valByDate.get(dt);
        if (!Number.isFinite(yv)) { started = false; continue; }
        const x = X(dt), y = YL(yv);
        dPath += (started ? ` L ${x} ${y}` : ` M ${x} ${y}`);
        started = true;
      }

      paths += `
        <path class="series"
              data-hz="${hz}"
              data-metric="${metric}"
              data-axis="L"
              data-type="line"
              d="${dPath}"
              fill="none"
              stroke="${color}"
              stroke-width="2.4"
              stroke-dasharray="${dash}" />
      `;

      pts.forEach(p => {
        const x = X(p.asof), y = YL(p.y);
        points += `
          <circle class="pt"
                  data-hz="${hz}"
                  data-metric="${metric}"
                  data-axis="L"
                  data-type="line"
                  data-date="${p.asof}"
                  data-val="${p.y}"
                  cx="${x}" cy="${y}" r="10"
                  fill="transparent" stroke="transparent"></circle>
          <circle cx="${x}" cy="${y}" r="2.1" fill="${color}" opacity="0.95"></circle>
        `;
      });
    });
  });

  const invariantMetrics = metrics.filter(metric => metricLooksInvariant(sym, tag, metric, horizons, dates));
  const invNote = invariantMetrics.length ? ` • note: invariant across horizons: ${invariantMetrics.join(", ")}` : "";

  const axisLabelL = metricsL.length ? `L: ${metricsL.join(", ")}` : "";
  const axisLabelR = metricsR.length ? `R: ${metricsR.join(", ")}` : "";

  svg.innerHTML = `
    <rect x="0" y="0" width="${W}" height="${H}" fill="transparent"></rect>

    ${gridLinesL}
    ${ticksR}

    <!-- chart frame / axes (inside area) -->
    <line x1="${m.l}" x2="${W-m.r}" y1="${H-m.b}" y2="${H-m.b}" stroke="rgba(148,163,184,.25)" />
    <line x1="${m.l}" x2="${m.l}" y1="${m.t}" y2="${H-m.b}" stroke="rgba(148,163,184,.25)" />
    ${hasR ? `<line x1="${W-m.r}" x2="${W-m.r}" y1="${m.t}" y2="${H-m.b}" stroke="rgba(148,163,184,.18)" />` : ""}

    <text x="${m.l}" y="${m.t-5}" font-size="12" fill="rgba(148,163,184,.90)">
      ${sym} ${tag} • metrics=${metrics.join(", ")}
    </text>

    ${axisLabelL ? `<text x="${m.l}" y="${m.t+12}" font-size="11" fill="rgba(148,163,184,.70)">${axisLabelL}</text>` : ""}
    ${axisLabelR ? `<text x="${W-m.r}" y="${m.t+12}" text-anchor="end" font-size="11" fill="rgba(148,163,184,.60)">${axisLabelR}</text>` : ""}

    ${xLabels}

    ${zeroLine}
    ${bars}
    ${barHitAreas}

    ${paths}
    ${points}
  `;

  status(`${sym} ${tag} • metrics=${metrics.length} (L:${metricsL.length}, R:${metricsR.length}) • horizons=${horizons.length} • dates=${dates.length} • range=${dates[0]}–${dates[dates.length-1]}${invNote}`);

  /* ===== KPI snapshot for selected snapDate + first selected horizon ===== */
  const firstHz = horizons[0];
  const snapDate = $("snapDate").value;

  const rowsAll = DATA.filter(d=>d.symbol===sym && d.tag===tag);
  const rowsThisHz = rowsAll.filter(d=>d.horizon_ms===firstHz);

  METRICS = METRIC_ORDER.filter(k => rowsAll.some(r => Number.isFinite(Number(r[k]))));
  const row = rowsThisHz.find(d => d.asof === snapDate) || null;

  if(row){
    const SNAPSHOT_KEYS = ["asof","tag","symbol","horizon_ms","model_start","model_end","src_file","session","month","pnl_col"].concat(METRICS);
    $("kpi").innerHTML = SNAPSHOT_KEYS
      .filter(k=>k in row)
      .map(k=>`<div>${k}</div><div>${fmt(row[k])}</div>`)
      .join("");
  } else {
    $("kpi").innerHTML = `<div class="muted">No snapshot row for ${snapDate} (first horizon ${firstHz}).</div>`;
  }

  function showTip(evt, hz, metric, axis, type, date, val){
    tip.style.display = "block";
    tip.innerHTML = `
      <div><b>${sym} ${tag}</b></div>
      <div class="muted">date: ${date}</div>
      <div class="muted">horizon: ${hz} (${horizonLabel(Number(hz))})</div>
      <div class="muted">metric: ${metric} • ${type} • axis: ${axis}</div>
      <div>${metric}: <b>${fmt(Number(val))}</b></div>
    `;
    const rect = svg.getBoundingClientRect();
    tip.style.left = `${evt.clientX - rect.left + 12}px`;
    tip.style.top  = `${evt.clientY - rect.top + 12}px`;
  }
  function hideTip(){ tip.style.display = "none"; }

  svg.onmousemove = (evt) => {
    const target = evt.target;
    if(target && target.classList && target.classList.contains("pt")){
      showTip(
        evt,
        target.getAttribute("data-hz"),
        target.getAttribute("data-metric"),
        target.getAttribute("data-axis"),
        target.getAttribute("data-type") || "line",
        target.getAttribute("data-date"),
        target.getAttribute("data-val")
      );
    } else {
      hideTip();
    }
  };
  svg.onmouseleave = hideTip;
}

/* ---------- load ---------- */
async function main(){
  const res = await fetch("idt_daily_data.json?v="+Date.now(), {cache:"no-store"});
  DATA = await res.json();

  DATA.forEach(d=>{
    d.symbol = String(d.symbol).toUpperCase();
    d.tag = String(d.tag).toUpperCase();
    d.horizon_ms = Number(d.horizon_ms);
    d.asof = String(d.asof);
  });

  buildSelectors();

  $("sym").onchange = () => refreshAllForSymTag(true);
  $("tag").onchange = () => refreshAllForSymTag(true);

  $("dateStart").onchange = () => { clampEndGteStart(); setQuickActive(""); render(); };
  $("dateEnd").onchange   = () => { clampEndGteStart(); setQuickActive(""); render(); };

  $("snapDate").onchange = render;

  $("btnAll").onclick = () => {
    const sym = $("sym").value, tag = $("tag").value;
    const dates = allDatesFor(sym, tag);
    if(!dates.length) return;
    $("dateStart").value = dates[0];
    $("dateEnd").value = dates[dates.length-1];
    setQuickActive("all");
    render();
  };
  $("btnLast5").onclick = () => { setQuickActive("last5"); applyRangeLastN(5); };
  $("btnLast10").onclick = () => { setQuickActive("last10"); applyRangeLastN(10); };
}
main();
</script>
</body>
</html>